/* automatically generated by rust-bindgen 0.59.2 */

pub const LIBTELNET_INCLUDE: u32 = 1;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const TELNET_IAC: u32 = 255;
pub const TELNET_DONT: u32 = 254;
pub const TELNET_DO: u32 = 253;
pub const TELNET_WONT: u32 = 252;
pub const TELNET_WILL: u32 = 251;
pub const TELNET_SB: u32 = 250;
pub const TELNET_GA: u32 = 249;
pub const TELNET_EL: u32 = 248;
pub const TELNET_EC: u32 = 247;
pub const TELNET_AYT: u32 = 246;
pub const TELNET_AO: u32 = 245;
pub const TELNET_IP: u32 = 244;
pub const TELNET_BREAK: u32 = 243;
pub const TELNET_DM: u32 = 242;
pub const TELNET_NOP: u32 = 241;
pub const TELNET_SE: u32 = 240;
pub const TELNET_EOR: u32 = 239;
pub const TELNET_ABORT: u32 = 238;
pub const TELNET_SUSP: u32 = 237;
pub const TELNET_EOF: u32 = 236;
pub const TELNET_TELOPT_BINARY: u32 = 0;
pub const TELNET_TELOPT_ECHO: u32 = 1;
pub const TELNET_TELOPT_RCP: u32 = 2;
pub const TELNET_TELOPT_SGA: u32 = 3;
pub const TELNET_TELOPT_NAMS: u32 = 4;
pub const TELNET_TELOPT_STATUS: u32 = 5;
pub const TELNET_TELOPT_TM: u32 = 6;
pub const TELNET_TELOPT_RCTE: u32 = 7;
pub const TELNET_TELOPT_NAOL: u32 = 8;
pub const TELNET_TELOPT_NAOP: u32 = 9;
pub const TELNET_TELOPT_NAOCRD: u32 = 10;
pub const TELNET_TELOPT_NAOHTS: u32 = 11;
pub const TELNET_TELOPT_NAOHTD: u32 = 12;
pub const TELNET_TELOPT_NAOFFD: u32 = 13;
pub const TELNET_TELOPT_NAOVTS: u32 = 14;
pub const TELNET_TELOPT_NAOVTD: u32 = 15;
pub const TELNET_TELOPT_NAOLFD: u32 = 16;
pub const TELNET_TELOPT_XASCII: u32 = 17;
pub const TELNET_TELOPT_LOGOUT: u32 = 18;
pub const TELNET_TELOPT_BM: u32 = 19;
pub const TELNET_TELOPT_DET: u32 = 20;
pub const TELNET_TELOPT_SUPDUP: u32 = 21;
pub const TELNET_TELOPT_SUPDUPOUTPUT: u32 = 22;
pub const TELNET_TELOPT_SNDLOC: u32 = 23;
pub const TELNET_TELOPT_TTYPE: u32 = 24;
pub const TELNET_TELOPT_EOR: u32 = 25;
pub const TELNET_TELOPT_TUID: u32 = 26;
pub const TELNET_TELOPT_OUTMRK: u32 = 27;
pub const TELNET_TELOPT_TTYLOC: u32 = 28;
pub const TELNET_TELOPT_3270REGIME: u32 = 29;
pub const TELNET_TELOPT_X3PAD: u32 = 30;
pub const TELNET_TELOPT_NAWS: u32 = 31;
pub const TELNET_TELOPT_TSPEED: u32 = 32;
pub const TELNET_TELOPT_LFLOW: u32 = 33;
pub const TELNET_TELOPT_LINEMODE: u32 = 34;
pub const TELNET_TELOPT_XDISPLOC: u32 = 35;
pub const TELNET_TELOPT_ENVIRON: u32 = 36;
pub const TELNET_TELOPT_AUTHENTICATION: u32 = 37;
pub const TELNET_TELOPT_ENCRYPT: u32 = 38;
pub const TELNET_TELOPT_NEW_ENVIRON: u32 = 39;
pub const TELNET_TELOPT_MSSP: u32 = 70;
pub const TELNET_TELOPT_COMPRESS: u32 = 85;
pub const TELNET_TELOPT_COMPRESS2: u32 = 86;
pub const TELNET_TELOPT_ZMP: u32 = 93;
pub const TELNET_TELOPT_EXOPL: u32 = 255;
pub const TELNET_TELOPT_MCCP2: u32 = 86;
pub const TELNET_TTYPE_IS: u32 = 0;
pub const TELNET_TTYPE_SEND: u32 = 1;
pub const TELNET_ENVIRON_IS: u32 = 0;
pub const TELNET_ENVIRON_SEND: u32 = 1;
pub const TELNET_ENVIRON_INFO: u32 = 2;
pub const TELNET_ENVIRON_VAR: u32 = 0;
pub const TELNET_ENVIRON_VALUE: u32 = 1;
pub const TELNET_ENVIRON_ESC: u32 = 2;
pub const TELNET_ENVIRON_USERVAR: u32 = 3;
pub const TELNET_MSSP_VAR: u32 = 1;
pub const TELNET_MSSP_VAL: u32 = 2;
pub const TELNET_FLAG_PROXY: u32 = 1;
pub const TELNET_FLAG_NVT_EOL: u32 = 2;
pub const TELNET_FLAG_TRANSMIT_BINARY: u32 = 32;
pub const TELNET_FLAG_RECEIVE_BINARY: u32 = 64;
pub const TELNET_PFLAG_DEFLATE: u32 = 128;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    );
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_pctype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_mb_cur_max as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_lc_codepage as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__crt_locale_pointers>())).locinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__crt_locale_pointers>())).mbcinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._Wchar as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._Byte as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._State as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = size_t;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __threadid() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __threadhandle() -> usize;
}
#[doc = " state tracker -- private data structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_t {
    _unused: [u8; 0],
}
#[doc = "< no error"]
pub const telnet_error_t_TELNET_EOK: telnet_error_t = 0;
#[doc = "< invalid parameter, or API misuse"]
pub const telnet_error_t_TELNET_EBADVAL: telnet_error_t = 1;
#[doc = "< memory allocation failure"]
pub const telnet_error_t_TELNET_ENOMEM: telnet_error_t = 2;
#[doc = "< data exceeds buffer size"]
pub const telnet_error_t_TELNET_EOVERFLOW: telnet_error_t = 3;
#[doc = "< invalid sequence of special bytes"]
pub const telnet_error_t_TELNET_EPROTOCOL: telnet_error_t = 4;
#[doc = "< error handling compressed streams"]
pub const telnet_error_t_TELNET_ECOMPRESS: telnet_error_t = 5;
#[doc = " error codes"]
pub type telnet_error_t = ::std::os::raw::c_int;
#[doc = "< raw text data has been received"]
pub const telnet_event_type_t_TELNET_EV_DATA: telnet_event_type_t = 0;
#[doc = "< data needs to be sent to the peer"]
pub const telnet_event_type_t_TELNET_EV_SEND: telnet_event_type_t = 1;
#[doc = "< generic IAC code received"]
pub const telnet_event_type_t_TELNET_EV_IAC: telnet_event_type_t = 2;
#[doc = "< WILL option negotiation received"]
pub const telnet_event_type_t_TELNET_EV_WILL: telnet_event_type_t = 3;
#[doc = "< WONT option neogitation received"]
pub const telnet_event_type_t_TELNET_EV_WONT: telnet_event_type_t = 4;
#[doc = "< DO option negotiation received"]
pub const telnet_event_type_t_TELNET_EV_DO: telnet_event_type_t = 5;
#[doc = "< DONT option negotiation received"]
pub const telnet_event_type_t_TELNET_EV_DONT: telnet_event_type_t = 6;
#[doc = "< sub-negotiation data received"]
pub const telnet_event_type_t_TELNET_EV_SUBNEGOTIATION: telnet_event_type_t = 7;
#[doc = "< compression has been enabled"]
pub const telnet_event_type_t_TELNET_EV_COMPRESS: telnet_event_type_t = 8;
#[doc = "< ZMP command has been received"]
pub const telnet_event_type_t_TELNET_EV_ZMP: telnet_event_type_t = 9;
#[doc = "< TTYPE command has been received"]
pub const telnet_event_type_t_TELNET_EV_TTYPE: telnet_event_type_t = 10;
#[doc = "< ENVIRON command has been received"]
pub const telnet_event_type_t_TELNET_EV_ENVIRON: telnet_event_type_t = 11;
#[doc = "< MSSP command has been received"]
pub const telnet_event_type_t_TELNET_EV_MSSP: telnet_event_type_t = 12;
#[doc = "< recoverable error has occured"]
pub const telnet_event_type_t_TELNET_EV_WARNING: telnet_event_type_t = 13;
#[doc = "< non-recoverable error has occured"]
pub const telnet_event_type_t_TELNET_EV_ERROR: telnet_event_type_t = 14;
#[doc = " event codes"]
pub type telnet_event_type_t = ::std::os::raw::c_int;
#[doc = " environ/MSSP command information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_environ_t {
    #[doc = "< either TELNET_ENVIRON_VAR or TELNET_ENVIRON_USERVAR"]
    pub type_: ::std::os::raw::c_uchar,
    #[doc = "< name of the variable being set"]
    pub var: *mut ::std::os::raw::c_char,
    #[doc = "< value of variable being set; empty string if no value"]
    pub value: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_telnet_environ_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_environ_t>(),
        24usize,
        concat!("Size of: ", stringify!(telnet_environ_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_environ_t>(),
        8usize,
        concat!("Alignment of ", stringify!(telnet_environ_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_environ_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_environ_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_environ_t>())).var as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_environ_t),
            "::",
            stringify!(var)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_environ_t>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_environ_t),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " event information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union telnet_event_t {
    #[doc = " \\brief Event type"]
    #[doc = ""]
    #[doc = " The type field will determine which of the other event structure fields"]
    #[doc = " have been filled in.  For instance, if the event type is TELNET_EV_ZMP,"]
    #[doc = " then the zmp event field (and ONLY the zmp event field) will be filled"]
    #[doc = " in."]
    pub type_: telnet_event_type_t,
    #[doc = "< DATA and SEND"]
    pub data: telnet_event_t_data_t,
    #[doc = "< WARNING and ERROR"]
    pub error: telnet_event_t_error_t,
    #[doc = "< IAC"]
    pub iac: telnet_event_t_iac_t,
    #[doc = "< WILL, WONT, DO, DONT"]
    pub neg: telnet_event_t_negotiate_t,
    #[doc = "< SB"]
    pub sub: telnet_event_t_subnegotiate_t,
    #[doc = "< ZMP"]
    pub zmp: telnet_event_t_zmp_t,
    #[doc = "< TTYPE"]
    pub ttype: telnet_event_t_ttype_t,
    #[doc = "< COMPRESS"]
    pub compress: telnet_event_t_compress_t,
    #[doc = "< ENVIRON, NEW-ENVIRON"]
    pub environ: telnet_event_t_environ_t,
    #[doc = "< MSSP"]
    pub mssp: telnet_event_t_mssp_t,
}
#[doc = " data event: for DATA and SEND events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_event_t_data_t {
    #[doc = "< alias for type"]
    pub _type: telnet_event_type_t,
    #[doc = "< byte buffer"]
    pub buffer: *const ::std::os::raw::c_char,
    #[doc = "< number of bytes in buffer"]
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_telnet_event_t_data_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_event_t_data_t>(),
        24usize,
        concat!("Size of: ", stringify!(telnet_event_t_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_event_t_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(telnet_event_t_data_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_data_t>()))._type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_data_t),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_data_t>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_data_t),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_data_t>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_data_t),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " WARNING and ERROR events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_event_t_error_t {
    #[doc = "< alias for type"]
    pub _type: telnet_event_type_t,
    #[doc = "< file the error occured in"]
    pub file: *const ::std::os::raw::c_char,
    #[doc = "< function the error occured in"]
    pub func: *const ::std::os::raw::c_char,
    #[doc = "< error message string"]
    pub msg: *const ::std::os::raw::c_char,
    #[doc = "< line of file error occured on"]
    pub line: ::std::os::raw::c_int,
    #[doc = "< error code"]
    pub errcode: telnet_error_t,
}
#[test]
fn bindgen_test_layout_telnet_event_t_error_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_event_t_error_t>(),
        40usize,
        concat!("Size of: ", stringify!(telnet_event_t_error_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_event_t_error_t>(),
        8usize,
        concat!("Alignment of ", stringify!(telnet_event_t_error_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_error_t>()))._type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_error_t),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_error_t>())).file as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_error_t),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_error_t>())).func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_error_t),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_error_t>())).msg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_error_t),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_error_t>())).line as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_error_t),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_error_t>())).errcode as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_error_t),
            "::",
            stringify!(errcode)
        )
    );
}
#[doc = " command event: for IAC"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_event_t_iac_t {
    #[doc = "< alias for type"]
    pub _type: telnet_event_type_t,
    #[doc = "< telnet command received"]
    pub cmd: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_telnet_event_t_iac_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_event_t_iac_t>(),
        8usize,
        concat!("Size of: ", stringify!(telnet_event_t_iac_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_event_t_iac_t>(),
        4usize,
        concat!("Alignment of ", stringify!(telnet_event_t_iac_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_iac_t>()))._type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_iac_t),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_iac_t>())).cmd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_iac_t),
            "::",
            stringify!(cmd)
        )
    );
}
#[doc = " negotiation event: WILL, WONT, DO, DONT"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_event_t_negotiate_t {
    #[doc = "< alias for type"]
    pub _type: telnet_event_type_t,
    #[doc = "< option being negotiated"]
    pub telopt: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_telnet_event_t_negotiate_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_event_t_negotiate_t>(),
        8usize,
        concat!("Size of: ", stringify!(telnet_event_t_negotiate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_event_t_negotiate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(telnet_event_t_negotiate_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<telnet_event_t_negotiate_t>()))._type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_negotiate_t),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<telnet_event_t_negotiate_t>())).telopt as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_negotiate_t),
            "::",
            stringify!(telopt)
        )
    );
}
#[doc = " subnegotiation event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_event_t_subnegotiate_t {
    #[doc = "< alias for type"]
    pub _type: telnet_event_type_t,
    #[doc = "< data of sub-negotiation"]
    pub buffer: *const ::std::os::raw::c_char,
    #[doc = "< number of bytes in buffer"]
    pub size: size_t,
    #[doc = "< option code for negotiation"]
    pub telopt: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_telnet_event_t_subnegotiate_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_event_t_subnegotiate_t>(),
        32usize,
        concat!("Size of: ", stringify!(telnet_event_t_subnegotiate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_event_t_subnegotiate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(telnet_event_t_subnegotiate_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<telnet_event_t_subnegotiate_t>()))._type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_subnegotiate_t),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<telnet_event_t_subnegotiate_t>())).buffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_subnegotiate_t),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<telnet_event_t_subnegotiate_t>())).size as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_subnegotiate_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<telnet_event_t_subnegotiate_t>())).telopt as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_subnegotiate_t),
            "::",
            stringify!(telopt)
        )
    );
}
#[doc = " ZMP event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_event_t_zmp_t {
    #[doc = "< alias for type"]
    pub _type: telnet_event_type_t,
    #[doc = "< array of argument string"]
    pub argv: *mut *const ::std::os::raw::c_char,
    #[doc = "< number of elements in argv"]
    pub argc: size_t,
}
#[test]
fn bindgen_test_layout_telnet_event_t_zmp_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_event_t_zmp_t>(),
        24usize,
        concat!("Size of: ", stringify!(telnet_event_t_zmp_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_event_t_zmp_t>(),
        8usize,
        concat!("Alignment of ", stringify!(telnet_event_t_zmp_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_zmp_t>()))._type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_zmp_t),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_zmp_t>())).argv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_zmp_t),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_zmp_t>())).argc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_zmp_t),
            "::",
            stringify!(argc)
        )
    );
}
#[doc = " TTYPE event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_event_t_ttype_t {
    #[doc = "< alias for type"]
    pub _type: telnet_event_type_t,
    #[doc = "< TELNET_TTYPE_IS or TELNET_TTYPE_SEND"]
    pub cmd: ::std::os::raw::c_uchar,
    #[doc = "< terminal type name (IS only)"]
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_telnet_event_t_ttype_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_event_t_ttype_t>(),
        16usize,
        concat!("Size of: ", stringify!(telnet_event_t_ttype_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_event_t_ttype_t>(),
        8usize,
        concat!("Alignment of ", stringify!(telnet_event_t_ttype_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_ttype_t>()))._type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_ttype_t),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_ttype_t>())).cmd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_ttype_t),
            "::",
            stringify!(cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_ttype_t>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_ttype_t),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " COMPRESS event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_event_t_compress_t {
    #[doc = "< alias for type"]
    pub _type: telnet_event_type_t,
    #[doc = "< 1 if compression is enabled,"]
    #[doc = "0 if disabled"]
    pub state: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_telnet_event_t_compress_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_event_t_compress_t>(),
        8usize,
        concat!("Size of: ", stringify!(telnet_event_t_compress_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_event_t_compress_t>(),
        4usize,
        concat!("Alignment of ", stringify!(telnet_event_t_compress_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_compress_t>()))._type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_compress_t),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_compress_t>())).state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_compress_t),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " ENVIRON/NEW-ENVIRON event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_event_t_environ_t {
    #[doc = "< alias for type"]
    pub _type: telnet_event_type_t,
    #[doc = "< array of variable values"]
    pub values: *const telnet_environ_t,
    #[doc = "< number of elements in values"]
    pub size: size_t,
    #[doc = "< SEND, IS, or INFO"]
    pub cmd: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_telnet_event_t_environ_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_event_t_environ_t>(),
        32usize,
        concat!("Size of: ", stringify!(telnet_event_t_environ_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_event_t_environ_t>(),
        8usize,
        concat!("Alignment of ", stringify!(telnet_event_t_environ_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_environ_t>()))._type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_environ_t),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_environ_t>())).values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_environ_t),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_environ_t>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_environ_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_environ_t>())).cmd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_environ_t),
            "::",
            stringify!(cmd)
        )
    );
}
#[doc = " MSSP event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_event_t_mssp_t {
    #[doc = "< alias for type"]
    pub _type: telnet_event_type_t,
    #[doc = "< array of variable values"]
    pub values: *const telnet_environ_t,
    #[doc = "< number of elements in values"]
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_telnet_event_t_mssp_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_event_t_mssp_t>(),
        24usize,
        concat!("Size of: ", stringify!(telnet_event_t_mssp_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_event_t_mssp_t>(),
        8usize,
        concat!("Alignment of ", stringify!(telnet_event_t_mssp_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_mssp_t>()))._type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_mssp_t),
            "::",
            stringify!(_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_mssp_t>())).values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_mssp_t),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t_mssp_t>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t_mssp_t),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_telnet_event_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_event_t>(),
        40usize,
        concat!("Size of: ", stringify!(telnet_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_event_t>(),
        8usize,
        concat!("Alignment of ", stringify!(telnet_event_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t>())).iac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t),
            "::",
            stringify!(iac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t>())).neg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t),
            "::",
            stringify!(neg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t>())).sub as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t),
            "::",
            stringify!(sub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t>())).zmp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t),
            "::",
            stringify!(zmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t>())).ttype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t),
            "::",
            stringify!(ttype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t>())).compress as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t),
            "::",
            stringify!(compress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t>())).environ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t),
            "::",
            stringify!(environ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_event_t>())).mssp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_event_t),
            "::",
            stringify!(mssp)
        )
    );
}
#[doc = " \\brief event handler"]
#[doc = ""]
#[doc = " This is the type of function that must be passed to"]
#[doc = " telnet_init() when creating a new telnet object.  The"]
#[doc = " function will be invoked once for every event generated"]
#[doc = " by the libtelnet protocol parser."]
#[doc = ""]
#[doc = " \\param telnet    The telnet object that generated the event"]
#[doc = " \\param event     Event structure with details about the event"]
#[doc = " \\param user_data User-supplied pointer"]
pub type telnet_event_handler_t = ::std::option::Option<
    unsafe extern "C" fn(
        telnet: *mut telnet_t,
        event: *mut telnet_event_t,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " telopt support table element; use telopt of -1 for end marker"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct telnet_telopt_t {
    #[doc = "< one of the TELOPT codes or -1"]
    pub telopt: ::std::os::raw::c_short,
    #[doc = "< TELNET_WILL or TELNET_WONT"]
    pub us: ::std::os::raw::c_uchar,
    #[doc = "< TELNET_DO or TELNET_DONT"]
    pub him: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_telnet_telopt_t() {
    assert_eq!(
        ::std::mem::size_of::<telnet_telopt_t>(),
        4usize,
        concat!("Size of: ", stringify!(telnet_telopt_t))
    );
    assert_eq!(
        ::std::mem::align_of::<telnet_telopt_t>(),
        2usize,
        concat!("Alignment of ", stringify!(telnet_telopt_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_telopt_t>())).telopt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_telopt_t),
            "::",
            stringify!(telopt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_telopt_t>())).us as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_telopt_t),
            "::",
            stringify!(us)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<telnet_telopt_t>())).him as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(telnet_telopt_t),
            "::",
            stringify!(him)
        )
    );
}
extern "C" {
    #[doc = " \\brief Initialize a telnet state tracker."]
    #[doc = ""]
    #[doc = " This function initializes a new state tracker, which is used for all"]
    #[doc = " other libtelnet functions.  Each connection must have its own"]
    #[doc = " telnet state tracker object."]
    #[doc = ""]
    #[doc = " \\param telopts   Table of TELNET options the application supports."]
    #[doc = " \\param eh        Event handler function called for every event."]
    #[doc = " \\param flags     0 or TELNET_FLAG_PROXY."]
    #[doc = " \\param user_data Optional data pointer that will be passsed to eh."]
    #[doc = " \\return Telnet state tracker object."]
    pub fn telnet_init(
        telopts: *const telnet_telopt_t,
        eh: telnet_event_handler_t,
        flags: ::std::os::raw::c_uchar,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut telnet_t;
}
extern "C" {
    #[doc = " \\brief Free up any memory allocated by a state tracker."]
    #[doc = ""]
    #[doc = " This function must be called when a telnet state tracker is no"]
    #[doc = " longer needed (such as after the connection has been closed) to"]
    #[doc = " release any memory resources used by the state tracker."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    pub fn telnet_free(telnet: *mut telnet_t);
}
extern "C" {
    #[doc = " \\brief Push a byte buffer into the state tracker."]
    #[doc = ""]
    #[doc = " Passes one or more bytes to the telnet state tracker for"]
    #[doc = " protocol parsing.  The byte buffer is most often going to be"]
    #[doc = " the buffer that recv() was called for while handling the"]
    #[doc = " connection."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param buffer Pointer to byte buffer."]
    #[doc = " \\param size   Number of bytes pointed to by buffer."]
    pub fn telnet_recv(telnet: *mut telnet_t, buffer: *const ::std::os::raw::c_char, size: size_t);
}
extern "C" {
    #[doc = " \\brief Send a telnet command."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param cmd    Command to send."]
    pub fn telnet_iac(telnet: *mut telnet_t, cmd: ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " \\brief Send negotiation command."]
    #[doc = ""]
    #[doc = " Internally, libtelnet uses RFC1143 option negotiation rules."]
    #[doc = " The negotiation commands sent with this function may be ignored"]
    #[doc = " if they are determined to be redundant."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param cmd    TELNET_WILL, TELNET_WONT, TELNET_DO, or TELNET_DONT."]
    #[doc = " \\param opt    One of the TELNET_TELOPT_* values."]
    pub fn telnet_negotiate(
        telnet: *mut telnet_t,
        cmd: ::std::os::raw::c_uchar,
        opt: ::std::os::raw::c_uchar,
    );
}
extern "C" {
    #[doc = " Send non-command data (escapes IAC bytes)."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param buffer Buffer of bytes to send."]
    #[doc = " \\param size   Number of bytes to send."]
    pub fn telnet_send(telnet: *mut telnet_t, buffer: *const ::std::os::raw::c_char, size: size_t);
}
extern "C" {
    #[doc = " Send non-command text (escapes IAC bytes and translates"]
    #[doc = " \\\\r -> CR-NUL and \\\\n -> CR-LF unless in BINARY mode."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param buffer Buffer of bytes to send."]
    #[doc = " \\param size   Number of bytes to send."]
    pub fn telnet_send_text(
        telnet: *mut telnet_t,
        buffer: *const ::std::os::raw::c_char,
        size: size_t,
    );
}
extern "C" {
    #[doc = " \\brief Begin a sub-negotiation command."]
    #[doc = ""]
    #[doc = " Sends IAC SB followed by the telopt code.  All following data sent"]
    #[doc = " will be part of the sub-negotiation, until telnet_finish_sb() is"]
    #[doc = " called."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param telopt One of the TELNET_TELOPT_* values."]
    pub fn telnet_begin_sb(telnet: *mut telnet_t, telopt: ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " \\brief Shortcut for sending a complete subnegotiation buffer."]
    #[doc = ""]
    #[doc = " Equivalent to:"]
    #[doc = "   telnet_begin_sb(telnet, telopt);"]
    #[doc = "   telnet_send(telnet, buffer, size);"]
    #[doc = "   telnet_finish_sb(telnet);"]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker format."]
    #[doc = " \\param telopt One of the TELNET_TELOPT_* values."]
    #[doc = " \\param buffer Byte buffer for sub-negotiation data."]
    #[doc = " \\param size   Number of bytes to use for sub-negotiation data."]
    pub fn telnet_subnegotiation(
        telnet: *mut telnet_t,
        telopt: ::std::os::raw::c_uchar,
        buffer: *const ::std::os::raw::c_char,
        size: size_t,
    );
}
extern "C" {
    #[doc = " \\brief Begin sending compressed data."]
    #[doc = ""]
    #[doc = " This function will begein sending data using the COMPRESS2 option,"]
    #[doc = " which enables the use of zlib to compress data sent to the client."]
    #[doc = " The client must offer support for COMPRESS2 with option negotiation,"]
    #[doc = " and zlib support must be compiled into libtelnet."]
    #[doc = ""]
    #[doc = " Only the server may call this command."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    pub fn telnet_begin_compress2(telnet: *mut telnet_t);
}
extern "C" {
    #[doc = " \\brief Send formatted data."]
    #[doc = ""]
    #[doc = " This function is a wrapper around telnet_send().  It allows using"]
    #[doc = " printf-style formatting."]
    #[doc = ""]
    #[doc = " Additionally, this function will translate \\\\r to the CR NUL construct and"]
    #[doc = " \\\\n with CR LF, as well as automatically escaping IAC bytes like"]
    #[doc = " telnet_send()."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param fmt    Format string."]
    #[doc = " \\return Number of bytes sent."]
    pub fn telnet_printf(
        telnet: *mut telnet_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Send formatted data."]
    #[doc = ""]
    #[doc = " See telnet_printf()."]
    pub fn telnet_vprintf(
        telnet: *mut telnet_t,
        fmt: *const ::std::os::raw::c_char,
        va: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Send formatted data (no newline escaping)."]
    #[doc = ""]
    #[doc = " This behaves identically to telnet_printf(), except that the \\\\r and \\\\n"]
    #[doc = " characters are not translated.  The IAC byte is still escaped as normal"]
    #[doc = " with telnet_send()."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param fmt    Format string."]
    #[doc = " \\return Number of bytes sent."]
    pub fn telnet_raw_printf(
        telnet: *mut telnet_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Send formatted data (no newline escaping)."]
    #[doc = ""]
    #[doc = " See telnet_raw_printf()."]
    pub fn telnet_raw_vprintf(
        telnet: *mut telnet_t,
        fmt: *const ::std::os::raw::c_char,
        va: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\brief Begin a new set of NEW-ENVIRON values to request or send."]
    #[doc = ""]
    #[doc = " This function will begin the sub-negotiation block for sending or"]
    #[doc = " requesting NEW-ENVIRON values."]
    #[doc = ""]
    #[doc = " The telnet_finish_newenviron() macro must be called after this"]
    #[doc = " function to terminate the NEW-ENVIRON command."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param type   One of TELNET_ENVIRON_SEND, TELNET_ENVIRON_IS, or"]
    #[doc = "               TELNET_ENVIRON_INFO."]
    pub fn telnet_begin_newenviron(telnet: *mut telnet_t, type_: ::std::os::raw::c_uchar);
}
extern "C" {
    #[doc = " \\brief Send a NEW-ENVIRON variable name or value."]
    #[doc = ""]
    #[doc = " This can only be called between calls to telnet_begin_newenviron() and"]
    #[doc = " telnet_finish_newenviron()."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param type   One of TELNET_ENVIRON_VAR, TELNET_ENVIRON_USERVAR, or"]
    #[doc = "               TELNET_ENVIRON_VALUE."]
    #[doc = " \\param string Variable name or value."]
    pub fn telnet_newenviron_value(
        telnet: *mut telnet_t,
        type_: ::std::os::raw::c_uchar,
        string: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\brief Send the TERMINAL-TYPE SEND command."]
    #[doc = ""]
    #[doc = " Sends the sequence IAC TERMINAL-TYPE SEND."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    pub fn telnet_ttype_send(telnet: *mut telnet_t);
}
extern "C" {
    #[doc = " \\brief Send the TERMINAL-TYPE IS command."]
    #[doc = ""]
    #[doc = " Sends the sequence IAC TERMINAL-TYPE IS \"string\"."]
    #[doc = ""]
    #[doc = " According to the RFC, the recipient of a TERMINAL-TYPE SEND shall"]
    #[doc = " send the next possible terminal-type the client supports.  Upon sending"]
    #[doc = " the type, the client should switch modes to begin acting as the terminal"]
    #[doc = " type is just sent."]
    #[doc = ""]
    #[doc = " The server may continue sending TERMINAL-TYPE IS until it receives a"]
    #[doc = " terminal type is understands.  To indicate to the server that it has"]
    #[doc = " reached the end of the available optoins, the client must send the last"]
    #[doc = " terminal type a second time.  When the server receives the same terminal"]
    #[doc = " type twice in a row, it knows it has seen all available terminal types."]
    #[doc = ""]
    #[doc = " After the last terminal type is sent, if the client receives another"]
    #[doc = " TERMINAL-TYPE SEND command, it must begin enumerating the available"]
    #[doc = " terminal types from the very beginning.  This allows the server to"]
    #[doc = " scan the available types for a preferred terminal type and, if none"]
    #[doc = " is found, to then ask the client to switch to an acceptable"]
    #[doc = " alternative."]
    #[doc = ""]
    #[doc = " Note that if the client only supports a single terminal type, then"]
    #[doc = " simply sending that one type in response to every SEND will satisfy"]
    #[doc = " the behavior requirements."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param ttype  Name of the terminal-type being sent."]
    pub fn telnet_ttype_is(telnet: *mut telnet_t, ttype: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " \\brief Send a ZMP command."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param argc   Number of ZMP commands being sent."]
    #[doc = " \\param argv   Array of argument strings."]
    pub fn telnet_send_zmp(
        telnet: *mut telnet_t,
        argc: size_t,
        argv: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " \\brief Send a ZMP command."]
    #[doc = ""]
    #[doc = " Arguments are listed out in var-args style.  After the last argument, a"]
    #[doc = " NULL pointer must be passed in as a sentinel value."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    pub fn telnet_send_zmpv(telnet: *mut telnet_t, ...);
}
extern "C" {
    #[doc = " \\brief Send a ZMP command."]
    #[doc = ""]
    #[doc = " See telnet_send_zmpv()."]
    pub fn telnet_send_vzmpv(telnet: *mut telnet_t, va: va_list);
}
extern "C" {
    #[doc = " \\brief Begin sending a ZMP command"]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param cmd    The first argument (command name) for the ZMP command."]
    pub fn telnet_begin_zmp(telnet: *mut telnet_t, cmd: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " \\brief Send a ZMP command argument."]
    #[doc = ""]
    #[doc = " \\param telnet Telnet state tracker object."]
    #[doc = " \\param arg    Telnet argument string."]
    pub fn telnet_zmp_arg(telnet: *mut telnet_t, arg: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
